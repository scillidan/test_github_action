name: Create Releases (All *-eng dictionaries in one release)

on:
  schedule:
    # 00:00 on the 1st of every month (UTC)
    - cron: '0 0 1 * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  # First job: discover all *-eng dictionaries from the FreeDict website
  discover-dictionaries:
    runs-on: ubuntu-latest
    outputs:
      dictionaries: ${{ steps.set-output.outputs.dictionaries }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl

      - name: Discover all *-eng dictionaries
        id: discover
        run: |
          echo "Discovering all *-eng dictionaries from FreeDict..."
          
          # Fetch the main dictionary listing page
          html=$(curl -s -L -A "GitHub-Actions-CI" "https://download.freedict.org/dictionaries/")
          
          # Extract all language pair links
          lang_links=$(echo "$html" | grep -oP 'href="([a-z]{3}-[a-z]{3}/)"' | grep -oP '[a-z]{3}-[a-z]{3}' || true)
          
          if [[ -z "$lang_links" ]]; then
            echo "No language links found"
            echo "dictionaries=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Filter for *-eng dictionaries (any language to English)
          eng_dicts=()
          while IFS= read -r link; do
            if [[ "$link" == *"-eng" && "$link" != "eng-eng" ]]; then
              eng_dicts+=("$link")
              echo "Found: $link"
            fi
          done <<< "$lang_links"
          
          # Remove duplicates and sort
          if [[ ${#eng_dicts[@]} -gt 0 ]]; then
            readarray -t unique_dicts < <(printf "%s\n" "${eng_dicts[@]}" | sort -u)
          else
            unique_dicts=()
          fi
          
          if [[ ${#unique_dicts[@]} -eq 0 ]]; then
            echo "No *-eng dictionaries found"
            echo "dictionaries=[]" >> $GITHUB_OUTPUT
          else
            echo "Found ${#unique_dicts[@]} *-eng dictionaries"
            # Convert array to JSON
            json_array="["
            for ((i=0; i<${#unique_dicts[@]}; i++)); do
              if [[ $i -gt 0 ]]; then
                json_array+=","
              fi
              json_array+="\"${unique_dicts[$i]}\""
            done
            json_array+="]"
            echo "dictionaries=$json_array" >> $GITHUB_OUTPUT
          fi

      - name: Set output
        id: set-output
        run: |
          if [[ -n "${{ steps.discover.outputs.dictionaries }}" ]]; then
            echo "dictionaries=${{ steps.discover.outputs.dictionaries }}" >> $GITHUB_OUTPUT
          else
            echo "dictionaries=[]" >> $GITHUB_OUTPUT
          fi

  # Second job: process all dictionaries sequentially
  process-all-dictionaries:
    needs: discover-dictionaries
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full zip curl

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install pyglossary and dependencies
        run: pip install pyglossary lxml beautifulsoup4 python-idzip tqdm pyicu

      - name: Parse dictionary list
        id: parse-dicts
        run: |
          # Read the JSON array and convert to bash array
          dicts_json='${{ needs.discover-dictionaries.outputs.dictionaries }}'
          if [[ "$dicts_json" == "[]" ]]; then
            echo "No dictionaries to process"
            echo "dictionaries_list=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Remove brackets and quotes, then convert to array
          dicts_json_clean=$(echo "$dicts_json" | sed 's/\[\|\]//g' | sed 's/"//g')
          IFS=',' read -r -a DICT_ARRAY <<< "$dicts_json_clean"
          
          echo "Processing ${#DICT_ARRAY[@]} dictionaries sequentially"
          echo "Dictionary list: ${DICT_ARRAY[@]}"
          
          # Store array as string for use in subsequent steps
          printf -v dicts_str '%s,' "${DICT_ARRAY[@]}"
          dicts_str=${dicts_str%,}
          echo "dictionaries_list=$dicts_str" >> $GITHUB_OUTPUT

      - name: Process dictionaries sequentially
        env:
          DICTIONARIES: ${{ steps.parse-dicts.outputs.dictionaries_list }}
        run: |
          # Split the comma-separated list into array
          IFS=',' read -r -a DICT_ARRAY <<< "$DICTIONARIES"
          
          if [[ ${#DICT_ARRAY[@]} -eq 0 ]]; then
            echo "No dictionaries to process"
            exit 0
          fi
          
          # Create output directory
          mkdir -p processed-dictionaries
          
          # Process each dictionary sequentially
          for lang_pair in "${DICT_ARRAY[@]}"; do
            echo ""
            echo "========================================================================"
            echo "Processing dictionary: $lang_pair"
            echo "========================================================================"
            
            # Create temporary directory for this dictionary
            temp_dir="temp_${lang_pair}"
            mkdir -p "$temp_dir"
            cd "$temp_dir"
            
            # Function to clean up and move to next dictionary
            process_next() {
              cd ..
              rm -rf "$temp_dir"
              echo "Finished processing $lang_pair"
              echo ""
            }
            
            # Check for latest source version
            echo "Checking for latest version of $lang_pair..."
            
            base_url="https://download.freedict.org/dictionaries/$lang_pair/"
            echo "Checking URL: $base_url"
            
            # Try to fetch the dictionary page HTML
            html=$(curl -s -L -A "GitHub-Actions-CI" "$base_url" || echo "")
            
            # Check if the page exists
            if [[ -z "$html" ]] || [[ "$html" == *"404 Not Found"* ]] || [[ "$html" == *"Not Found"* ]]; then
              echo "Dictionary $lang_pair not found or returned 404, skipping"
              process_next
              continue
            fi
            
            # Extract version numbers from the page
            versions=$(echo "$html" | grep -oP 'href="(\d{4}\.\d{2}\.\d{2}/)"' | grep -oP '\d{4}\.\d{2}\.\d{2}' | sort -V)
            
            if [[ -z "$versions" ]]; then
              # Try older version format, e.g., 0.2.2/
              versions=$(echo "$html" | grep -oP 'href="(\d+\.\d+\.\d+/)"' | grep -oP '\d+\.\d+\.\d+' | sort -V)
            fi
            
            if [[ -z "$versions" ]]; then
              # Try extracting from download links
              versions=$(echo "$html" | grep -oP "freedict-$lang_pair-\d+\.\d+\.\d+" | grep -oP "\d+\.\d+\.\d+" | sort -V)
            fi
            
            if [[ -z "$versions" ]]; then
              echo "No versions found for $lang_pair, skipping"
              process_next
              continue
            fi
            
            # Get the latest (highest) version
            latest_version=$(echo "$versions" | tail -1)
            echo "Latest version for $lang_pair: $latest_version"
            
            # Create filesystem-safe version identifier
            if [[ "$latest_version" =~ ^[0-9]{4}\.[0-9]{2}\.[0-9]{2}$ ]]; then
              # New format: 2024.10.10 -> 20241010
              file_version=$(echo "$latest_version" | sed 's/\.//g')
              tag_version="$latest_version"
            else
              # Old format: 0.2.2 -> keep as is
              file_version="$latest_version"
              tag_version="$latest_version"
            fi
            
            # Check if this is a new version compared to last time
            last_version_file="../last_version_${lang_pair}.txt"
            if [[ -f $last_version_file ]]; then
              last_version=$(cat $last_version_file)
              if [[ "$latest_version" == "$last_version" ]]; then
                echo "No new version for $lang_pair, skipping."
                process_next
                continue
              fi
            fi
            
            # Try to download the source file
            filename="freedict-${lang_pair}-${latest_version}.src.tar.xz"
            downloaded=false
            
            # Try multiple possible URL patterns
            download_urls=(
              "${base_url}${latest_version}/$filename"
              "${base_url}$filename"
              "https://download.freedict.org/dictionaries/$lang_pair/$latest_version/$filename"
              "https://download.freedict.org/dictionaries/$lang_pair/$filename"
            )
            
            for url in "${download_urls[@]}"; do
              echo "Trying to download from: $url"
              if curl -f -L -o "$filename" "$url"; then
                echo "Successfully downloaded from $url"
                downloaded=true
                break
              fi
              sleep 1
            done
            
            if [[ "$downloaded" != "true" ]]; then
              echo "Failed to download $lang_pair $latest_version, skipping"
              process_next
              continue
            fi
            
            # Extract the downloaded archive
            echo "Extracting $filename"
            
            if ! 7z x "$filename" -o. 2>/dev/null; then
              echo "Failed to extract $filename with 7z, trying tar directly..."
              tar -xf "$filename" || (echo "Failed to extract $filename"; process_next; continue)
            fi
            
            # Extract the .tar file (if it exists)
            tar_file="${filename%.xz}"
            if [[ -f "$tar_file" ]]; then
              7z x "$tar_file" -o. 2>/dev/null || tar -xf "$tar_file" || (echo "Failed to extract $tar_file"; process_next; continue)
            fi
            
            # Find and rename the extracted directory
            src_dir="freedict-${lang_pair}-${file_version}"
            
            # Try common directory name patterns
            possible_dirs=(
              "$lang_pair"
              "${lang_pair/_/-}"  # Replace underscore with dash if needed
              "$(echo $lang_pair | cut -d'-' -f1)-$(echo $lang_pair | cut -d'-' -f2)"
              "freedict-${lang_pair}-${latest_version}"
              "freedict-${lang_pair}-${file_version}"
            )
            
            for dir in "${possible_dirs[@]}"; do
              if [[ -d "$dir" ]]; then
                echo "Found directory: $dir"
                if [[ "$dir" != "$src_dir" ]]; then
                  mv "$dir" "$src_dir"
                  echo "Renamed $dir to $src_dir"
                fi
                break
              fi
            done
            
            # Fallback: if directory not found with expected names
            if [[ ! -d "$src_dir" ]]; then
              # Look for any directory containing the language pair
              found_dir=$(find . -maxdepth 1 -type d -name "*${lang_pair/_/-}*" -o -name "*${lang_pair}*" | grep -v "^\.$" | head -1)
              if [[ -n "$found_dir" ]]; then
                mv "$found_dir" "$src_dir"
                echo "Renamed found directory $found_dir to $src_dir"
              else
                # Create directory and move extracted files
                mkdir -p "$src_dir"
                find . -maxdepth 1 -type f -name "*.tei" -o -name "*.xml" -o -name "*.txt" | xargs -I {} mv {} "$src_dir/" 2>/dev/null || true
              fi
            fi
            
            # Find the TEI file
            tei_file=""
            src_lang=$(echo $lang_pair | cut -d'-' -f1)
            tgt_lang=$(echo $lang_pair | cut -d'-' -f2)
            
            possible_tei_files=(
              "$src_dir/$src_lang-$tgt_lang.tei"
              "$src_dir/$lang_pair.tei"
              "$src_dir/${lang_pair/_/-}.tei"
              "$src_dir/freedict-$lang_pair.tei"
              "$src_dir/freedict-${lang_pair/_/-}.tei"
              "$src_dir/tei"
              "$src_dir/*.tei"
              "$(find "$src_dir" -name "*.tei" -type f | head -1)"
            )
            
            for file in "${possible_tei_files[@]}"; do
              if [[ -f "$file" ]]; then
                tei_file="$file"
                echo "Found TEI file: $tei_file"
                break
              fi
            done
            
            # Fallback: look for XML files
            if [[ -z "$tei_file" ]]; then
              xml_file=$(find "$src_dir" -name "*.xml" -type f | head -1)
              if [[ -n "$xml_file" ]]; then
                tei_file="$xml_file"
                echo "Using XML file as TEI: $tei_file"
              else
                echo "ERROR: No TEI or XML file found for $lang_pair"
                ls -la "$src_dir/" || true
                process_next
                continue
              fi
            fi
            
            # Base filename for output
            base_filename="freedict-${lang_pair}-${file_version}"
            
            # Step 1: Convert TEI to tabfile format
            echo "Step 1: Converting to tabfile format..."
            pyglossary "$tei_file" "${base_filename}.txt" \
              --read-format=FreeDict --write-format=Tabfile
            
            # Step 2: Format the tabfile (if formatting script exists)
            if [[ -f "../text_format.py" ]]; then
              echo "Step 2: Formatting tabfile..."
              python ../text_format.py "${base_filename}.txt" "${base_filename}-formatted.txt"
            else
              echo "text_format.py not found, using original tabfile..."
              cp "${base_filename}.txt" "${base_filename}-formatted.txt"
            fi
            
            # Step 3: Convert to Stardict format
            echo "Step 3: Converting to Stardict format..."
            pyglossary "${base_filename}-formatted.txt" \
              "${base_filename}-stardict" \
              --read-format=Tabfile --write-format=Stardict \
              --name="FreeDict-$lang_pair"
            
            # Step 4: Convert HTML to ANSI (if conversion script exists)
            if [[ -f "../html2ansi.py" ]]; then
              echo "Step 4: Converting HTML to ANSI..."
              python ../html2ansi.py "${base_filename}-formatted.txt" "${base_filename}-formatted-html2ansi.txt"
            else
              echo "html2ansi.py not found, using formatted file..."
              cp "${base_filename}-formatted.txt" "${base_filename}-formatted-html2ansi.txt"
            fi
            
            # Step 5: Convert to SDCV format (Stardict variant)
            echo "Step 5: Converting to SDCV format..."
            pyglossary "${base_filename}-formatted-html2ansi.txt" \
              "${base_filename}-sdcv" \
              --read-format=Tabfile --write-format=Stardict \
              --name="FreeDict-$lang_pair"
            
            # Step 6: Convert to dictd format
            echo "Step 6: Converting to dictd format..."
            pyglossary "${base_filename}-formatted-html2ansi.txt" \
              "${base_filename}-dictd" \
              --read-format=Tabfile --write-format=DictOrg \
              --write-options="dictzip=true" --name="FreeDict-$lang_pair"
            
            # Step 7: Convert to Yomichan format
            echo "Step 7: Converting to Yomichan format..."
            pyglossary "${base_filename}-formatted.txt" \
              "${base_filename}-yomichan.zip" \
              --read-format=Tabfile --write-format=Yomichan \
              --name="FreeDict-$lang_pair"
            
            # Step 8: Convert to Aard2 format
            echo "Step 8: Converting to Aard2 format..."
            pyglossary "${base_filename}-formatted.txt" \
              "${base_filename}-aard2.slob" \
              --read-format=Tabfile --write-format=Aard2Slob \
              --name="FreeDict-$lang_pair"
            
            # Create ZIP archives for individual dictionaries
            echo "Creating ZIP archives..."
            
            # Create ZIP files for Stardict formats
            for prefix in "${base_filename}-stardict" "${base_filename}-sdcv"; do
              if [[ -f "${prefix}.ifo" && -f "${prefix}.idx" ]]; then
                # Check which dict file exists
                if [[ -f "${prefix}.dict.dz" ]]; then
                  dict_file="${prefix}.dict.dz"
                elif [[ -f "${prefix}.dict" ]]; then
                  dict_file="${prefix}.dict"
                else
                  echo "No dict file found for $prefix, skipping"
                  continue
                fi
                echo "Creating ${prefix}.zip"
                zip -j "${prefix}.zip" "${prefix}.ifo" "$dict_file" "${prefix}.idx"
              fi
            done
            
            # Create ZIP file for dictd format
            if [[ -f "${base_filename}-dictd.dict.dz" && \
                  -f "${base_filename}-dictd.index" ]]; then
              echo "Creating ${base_filename}-dictd.zip"
              zip -j "${base_filename}-dictd.zip" \
                "${base_filename}-dictd.dict.dz" \
                "${base_filename}-dictd.index"
            fi
            
            # Move all generated files to processed directory
            echo "Moving processed files..."
            for file in "${base_filename}"*; do
              if [[ -f "$file" ]]; then
                mv "$file" "../processed-dictionaries/"
              fi
            done
            
            # Save the current version for future comparison
            mkdir -p ../.version_cache
            echo "$latest_version" > "../.version_cache/last_version_${lang_pair}.txt"
            
            process_next
            
            # Small delay between dictionaries to avoid rate limiting
            sleep 2
          done
          
          echo "All dictionaries processed successfully"

      - name: Upload processed files
        uses: actions/upload-artifact@v4
        with:
          name: processed-dictionaries
          path: processed-dictionaries/
          retention-days: 1
          if-no-files-found: warn

  # Third job: create combined release
  create-combined-release:
    needs: [discover-dictionaries, process-all-dictionaries]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y zip

      - name: Get current date for release tag
        id: date
        run: |
          # Get current date in YYYYMMDD format
          current_date=$(date -u +"%Y%m%d")
          echo "RELEASE_DATE=$current_date" >> $GITHUB_OUTPUT
          echo "Release will be tagged as: $current_date"

      - name: Download processed dictionaries
        uses: actions/download-artifact@v4
        with:
          name: processed-dictionaries
          path: processed-dictionaries

      - name: List collected files
        run: |
          echo "Collected files:"
          find processed-dictionaries -type f | sort || echo "No files found"
          echo ""
          echo "Total files found: $(find processed-dictionaries -type f 2>/dev/null | wc -l || echo 0)"

      - name: Create collection zip files
        run: |
          echo "Creating collection zip files..."
          
          # Create collections directory
          mkdir -p collections
          
          # Check if we have any files
          if [[ ! -d "processed-dictionaries" ]] || [[ -z "$(ls -A processed-dictionaries/ 2>/dev/null)" ]]; then
            echo "No processed dictionaries found"
            exit 0
          fi
          
          # Copy all files to collections directory for easier processing
          cp processed-dictionaries/* collections/ 2>/dev/null || true
          
          # Create collections by format
          cd collections
          
          # 1. All aard2.slob files
          echo "Creating _all-aard2-slob.zip..."
          if ls *.slob 1> /dev/null 2>&1; then
            zip -j _all-aard2-slob.zip *.slob
            echo "Created _all-aard2-slob.zip with $(ls *.slob 2>/dev/null | wc -l) files"
          else
            echo "No aard2 files found"
          fi
          
          # 2. All dictd.zip files
          echo "Creating _all-dictd.zip..."
          if ls *-dictd.zip 1> /dev/null 2>&1; then
            zip -j _all-dictd.zip *-dictd.zip
            echo "Created _all-dictd.zip with $(ls *-dictd.zip 2>/dev/null | wc -l) files"
          else
            echo "No dictd files found"
          fi
          
          # 3. All *-formatted.txt files
          echo "Creating _all-formatted-txt.zip..."
          if ls *-formatted.txt 1> /dev/null 2>&1; then
            # Get all formatted.txt files (excluding html2ansi files)
            formatted_files=$(ls *-formatted.txt 2>/dev/null | grep -v html2ansi || true)
            if [[ -n "$formatted_files" ]]; then
              echo "$formatted_files" | xargs zip -j _all-formatted-txt.zip
              echo "Created _all-formatted-txt.zip with $(echo "$formatted_files" | wc -w) files"
            else
              echo "No formatted.txt files found"
            fi
          else
            echo "No formatted.txt files found"
          fi
          
          # 4. All *-stardict.zip files
          echo "Creating _all-stardict.zip..."
          if ls *-stardict.zip 1> /dev/null 2>&1; then
            zip -j _all-stardict.zip *-stardict.zip
            echo "Created _all-stardict.zip with $(ls *-stardict.zip 2>/dev/null | wc -l) files"
          else
            echo "No stardict files found"
          fi
          
          # 5. All *-sdcv.zip files
          echo "Creating _all-sdcv.zip..."
          if ls *-sdcv.zip 1> /dev/null 2>&1; then
            zip -j _all-sdcv.zip *-sdcv.zip
            echo "Created _all-sdcv.zip with $(ls *-sdcv.zip 2>/dev/null | wc -l) files"
          else
            echo "No sdcv files found"
          fi
          
          # 6. All *-yomichan.zip files
          echo "Creating _all-yomichan.zip..."
          if ls *-yomichan.zip 1> /dev/null 2>&1; then
            zip -j _all-yomichan.zip *-yomichan.zip
            echo "Created _all-yomichan.zip with $(ls *-yomichan.zip 2>/dev/null | wc -l) files"
          else
            echo "No yomichan files found"
          fi
          
          # 7. All original .txt files (excluding formatted and html2ansi)
          echo "Creating _all-original-txt.zip..."
          if ls *.txt 1> /dev/null 2>&1; then
            # Get all .txt files that are not formatted or html2ansi
            original_files=$(ls *.txt 2>/dev/null | grep -E '^[^-]+-[^-]+-[0-9]+\.txt$' || true)
            if [[ -n "$original_files" ]]; then
              echo "$original_files" | xargs zip -j _all-original-txt.zip
              echo "Created _all-original-txt.zip with $(echo "$original_files" | wc -w) files"
            else
              echo "No original .txt files found"
            fi
          else
            echo "No .txt files found"
          fi
          
          # 8. All *-formatted-html2ansi.txt files
          echo "Creating _all-formatted-html2ansi-txt.zip..."
          if ls *-formatted-html2ansi.txt 1> /dev/null 2>&1; then
            zip -j _all-formatted-html2ansi-txt.zip *-formatted-html2ansi.txt
            echo "Created _all-formatted-html2ansi-txt.zip with $(ls *-formatted-html2ansi.txt 2>/dev/null | wc -l) files"
          else
            echo "No html2ansi files found"
          fi
          
          echo ""
          echo "Collection files created:"
          ls -la _all-*.zip 2>/dev/null || echo "No collection files created"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.date.outputs.RELEASE_DATE }}
          name: FreeDict *-eng Collection ${{ steps.date.outputs.RELEASE_DATE }}
          files: |
            collections/_all-*.zip
          fail_on_unmatched_files: false
          draft: false
          prerelease: false
          body: ""
