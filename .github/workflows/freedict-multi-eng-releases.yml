name: Create Releases (All *-eng dictionaries in one release)

on:
  schedule:
    # 00:00 on the 1st of every month (UTC)
    - cron: '0 0 1 * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  # First job: discover all *-eng dictionaries from the FreeDict website
  discover-dictionaries:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl

      - name: Discover all *-eng dictionaries
        id: discover
        run: |
          echo "Discovering all *-eng dictionaries from FreeDict..."
          
          # Fetch the main dictionary listing page
          html=$(curl -s -L -A "GitHub-Actions-CI" "https://download.freedict.org/dictionaries/")
          
          # Extract all language pair links (e.g., afr-eng/, deu-eng/, etc.)
          # Match patterns like href="afr-eng/"
          lang_links=$(echo "$html" | grep -oP 'href="([a-z]{3}-[a-z]{3}/)"' | grep -oP '[a-z]{3}-[a-z]{3}' || true)
          
          if [[ -z "$lang_links" ]]; then
            echo "No language links found"
            # Create empty matrix
            echo '{"lang_pair": []}' > matrix.json
            exit 0
          fi
          
          # Filter for *-eng dictionaries (any language to English)
          eng_dicts=()
          while IFS= read -r link; do
            if [[ "$link" == *"-eng" && "$link" != "eng-eng" ]]; then
              eng_dicts+=("$link")
              echo "Found: $link"
            fi
          done <<< "$lang_links"
          
          # Remove duplicates and sort
          if [[ ${#eng_dicts[@]} -gt 0 ]]; then
            readarray -t unique_dicts < <(printf "%s\n" "${eng_dicts[@]}" | sort -u)
          else
            unique_dicts=()
          fi
          
          if [[ ${#unique_dicts[@]} -eq 0 ]]; then
            echo "No *-eng dictionaries found"
            # Create empty matrix
            echo '{"lang_pair": []}' > matrix.json
          else
            echo "Found ${#unique_dicts[@]} *-eng dictionaries"
            
            # Create JSON array manually
            matrix_json='{"lang_pair":['
            for ((i=0; i<${#unique_dicts[@]}; i++)); do
              if [[ $i -gt 0 ]]; then
                matrix_json+=','
              fi
              matrix_json+="\"${unique_dicts[$i]}\""
            done
            matrix_json+=']}'
            
            echo "Matrix JSON: $matrix_json"
            echo "$matrix_json" > matrix.json
          fi
          
          # Show the matrix file
          cat matrix.json

      - name: Set matrix output
        id: set-matrix
        run: |
          if [[ -f matrix.json ]]; then
            matrix_content=$(cat matrix.json)
            echo "matrix=${matrix_content}" >> $GITHUB_OUTPUT
          else
            echo '{"lang_pair": []}' > matrix.json
            echo "matrix={\"lang_pair\": []}" >> $GITHUB_OUTPUT
          fi

  # Second job: process each discovered dictionary in parallel
  process-dictionaries:
    needs: discover-dictionaries
    runs-on: ubuntu-latest
    # Use the dynamically discovered language pairs as a matrix
    strategy:
      matrix: ${{ fromJson(needs.discover-dictionaries.outputs.matrix) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full zip curl

      - name: Check for latest source version
        id: check_version
        run: |
          lang_pair="${{ matrix.lang_pair }}"
          echo "Processing dictionary: $lang_pair"
          
          base_url="https://download.freedict.org/dictionaries/$lang_pair/"
          echo "Checking URL: $base_url"
          
          # Try to fetch the dictionary page HTML
          html=$(curl -s -L -A "GitHub-Actions-CI" "$base_url" || echo "")
          
          # Check if the page exists
          if [[ -z "$html" ]] || [[ "$html" == *"404 Not Found"* ]] || [[ "$html" == *"Not Found"* ]]; then
            echo "Dictionary $lang_pair not found or returned 404, skipping"
            echo "should_continue=false" >> $GITHUB_OUTPUT
            echo "lang_pair=$lang_pair" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Extract version numbers from the page
          # Try to match <a href="version/"> format first
          versions=$(echo "$html" | grep -oP 'href="(\d{4}\.\d{2}\.\d{2}/)"' | grep -oP '\d{4}\.\d{2}\.\d{2}' | sort -V)
          
          if [[ -z "$versions" ]]; then
            # Try older version format, e.g., 0.2.2/
            versions=$(echo "$html" | grep -oP 'href="(\d+\.\d+\.\d+/)"' | grep -oP '\d+\.\d+\.\d+' | sort -V)
          fi
          
          if [[ -z "$versions" ]]; then
            # Try extracting from download links
            versions=$(echo "$html" | grep -oP "freedict-$lang_pair-\d+\.\d+\.\d+" | grep -oP "\d+\.\d+\.\d+" | sort -V)
          fi
          
          if [[ -z "$versions" ]]; then
            echo "No versions found for $lang_pair"
            echo "Page preview (first 500 chars): ${html:0:500}"
            echo "should_continue=false" >> $GITHUB_OUTPUT
            echo "lang_pair=$lang_pair" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get the latest (highest) version
          latest_version=$(echo "$versions" | tail -1)
          echo "Latest version for $lang_pair: $latest_version"
          
          # Create filesystem-safe version identifier
          if [[ "$latest_version" =~ ^[0-9]{4}\.[0-9]{2}\.[0-9]{2}$ ]]; then
            # New format: 2024.10.10 -> 20241010
            file_version=$(echo "$latest_version" | sed 's/\.//g')
            tag_version="$latest_version"
          else
            # Old format: 0.2.2 -> keep as is
            file_version="$latest_version"
            tag_version="$latest_version"
          fi
          
          # Check if this is a new version compared to last time
          last_version_file="last_version_${lang_pair}.txt"
          if [[ -f $last_version_file ]]; then
            last_version=$(cat $last_version_file)
            if [[ "$latest_version" == "$last_version" ]]; then
              echo "No new version for $lang_pair, skipping."
              echo "should_continue=false" >> $GITHUB_OUTPUT
              echo "lang_pair=$lang_pair" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Set outputs for subsequent steps
          echo "TAG_VERSION=$tag_version" >> $GITHUB_OUTPUT
          echo "FILE_VERSION=$file_version" >> $GITHUB_OUTPUT
          echo "LATEST_VERSION=$latest_version" >> $GITHUB_OUTPUT
          echo "lang_pair=$lang_pair" >> $GITHUB_OUTPUT
          
          # Try to download the source file
          filename="freedict-${lang_pair}-${latest_version}.src.tar.xz"
          
          # Try multiple possible URL patterns
          download_urls=(
            "${base_url}${latest_version}/$filename"
            "${base_url}$filename"
            "https://download.freedict.org/dictionaries/$lang_pair/$latest_version/$filename"
            "https://download.freedict.org/dictionaries/$lang_pair/$filename"
          )
          
          downloaded=false
          for url in "${download_urls[@]}"; do
            echo "Trying to download from: $url"
            if curl -f -L -o "$filename" "$url"; then
              echo "Successfully downloaded from $url"
              downloaded=true
              break
            fi
            sleep 1
          done
          
          if [[ "$downloaded" != "true" ]]; then
            echo "Failed to download $lang_pair $latest_version"
            echo "should_continue=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Save the current version for future comparison
          mkdir -p .version_cache
          echo "$latest_version" > "$last_version_file"
          echo "should_continue=true" >> $GITHUB_OUTPUT

      - name: Extract downloaded archive
        if: steps.check_version.outputs.should_continue == 'true'
        run: |
          lang_pair="${{ steps.check_version.outputs.lang_pair }}"
          latest_version="${{ steps.check_version.outputs.LATEST_VERSION }}"
          file_version="${{ steps.check_version.outputs.FILE_VERSION }}"
          filename="freedict-${lang_pair}-${latest_version}.src.tar.xz"
          
          echo "Extracting $filename"
          
          # Extract the .xz archive
          if ! 7z x "$filename" -o. 2>/dev/null; then
            echo "Failed to extract $filename with 7z, trying tar directly..."
            tar -xf "$filename" || exit 1
          fi
          
          # Extract the .tar file (if it exists)
          tar_file="${filename%.xz}"
          if [[ -f "$tar_file" ]]; then
            7z x "$tar_file" -o. 2>/dev/null || tar -xf "$tar_file" || exit 1
          fi
          
          # Find and rename the extracted directory
          src_dir="freedict-${lang_pair}-${file_version}"
          
          # Try common directory name patterns
          possible_dirs=(
            "$lang_pair"
            "${lang_pair/_/-}"  # Replace underscore with dash if needed
            "$(echo $lang_pair | cut -d'-' -f1)-$(echo $lang_pair | cut -d'-' -f2)"
            "freedict-${lang_pair}-${latest_version}"
            "freedict-${lang_pair}-${file_version}"
          )
          
          for dir in "${possible_dirs[@]}"; do
            if [[ -d "$dir" ]]; then
              echo "Found directory: $dir"
              if [[ "$dir" != "$src_dir" ]]; then
                mv "$dir" "$src_dir"
                echo "Renamed $dir to $src_dir"
              fi
              break
            fi
          done
          
          # Fallback: if directory not found with expected names
          if [[ ! -d "$src_dir" ]]; then
            # Look for any directory containing the language pair
            found_dir=$(find . -maxdepth 1 -type d -name "*${lang_pair/_/-}*" -o -name "*${lang_pair}*" | grep -v "^\.$" | head -1)
            if [[ -n "$found_dir" ]]; then
              mv "$found_dir" "$src_dir"
              echo "Renamed found directory $found_dir to $src_dir"
            else
              # Create directory and move extracted files
              mkdir -p "$src_dir"
              find . -maxdepth 1 -type f -name "*.tei" -o -name "*.xml" -o -name "*.txt" | xargs -I {} mv {} "$src_dir/" 2>/dev/null || true
            fi
          fi
          
          echo "SRC_DIR=$src_dir" >> $GITHUB_ENV
          ls -la "$src_dir/" || true

      - name: Set up Python
        if: steps.check_version.outputs.should_continue == 'true'
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install pyglossary and dependencies
        if: steps.check_version.outputs.should_continue == 'true'
        run: pip install pyglossary lxml beautifulsoup4 python-idzip tqdm pyicu

      - name: Convert dictionary with pyglossary
        if: steps.check_version.outputs.should_continue == 'true'
        run: |
          lang_pair="${{ steps.check_version.outputs.lang_pair }}"
          file_version="${{ steps.check_version.outputs.FILE_VERSION }}"
          src_dir="${{ env.SRC_DIR }}"
          
          echo "Converting $lang_pair, version $file_version"
          echo "Source directory: $src_dir"
          ls -la "$src_dir/" || echo "Cannot list source directory"
          
          # Extract source and target language codes
          src_lang=$(echo $lang_pair | cut -d'-' -f1)
          tgt_lang=$(echo $lang_pair | cut -d'-' -f2)
          
          # Find the TEI file
          tei_file=""
          possible_tei_files=(
            "$src_dir/$src_lang-$tgt_lang.tei"
            "$src_dir/$lang_pair.tei"
            "$src_dir/${lang_pair/_/-}.tei"
            "$src_dir/freedict-$lang_pair.tei"
            "$src_dir/freedict-${lang_pair/_/-}.tei"
            "$src_dir/tei"
            "$src_dir/*.tei"
            "$(find "$src_dir" -name "*.tei" -type f | head -1)"
          )
          
          for file in "${possible_tei_files[@]}"; do
            if [[ -f "$file" ]]; then
              tei_file="$file"
              echo "Found TEI file: $tei_file"
              break
            fi
          done
          
          # Fallback: look for XML files
          if [[ -z "$tei_file" ]]; then
            xml_file=$(find "$src_dir" -name "*.xml" -type f | head -1)
            if [[ -n "$xml_file" ]]; then
              tei_file="$xml_file"
              echo "Using XML file as TEI: $tei_file"
            else
              echo "ERROR: No TEI or XML file found for $lang_pair"
              ls -la "$src_dir/" || true
              exit 1
            fi
          fi
          
          # Base filename for output
          base_filename="_freedict-${lang_pair}-${file_version}"
          
          # Step 1: Convert TEI to tabfile format
          echo "Step 1: Converting to tabfile format..."
          pyglossary "$tei_file" "${base_filename}.txt" \
            --read-format=FreeDict --write-format=Tabfile
          
          # Step 2: Format the tabfile (if formatting script exists)
          if [[ -f "text_format.py" ]]; then
            echo "Step 2: Formatting tabfile..."
            python text_format.py "${base_filename}.txt" "${base_filename}-formatted.txt"
          else
            echo "text_format.py not found, using original tabfile..."
            cp "${base_filename}.txt" "${base_filename}-formatted.txt"
          fi
          
          # Step 3: Convert to Stardict format
          echo "Step 3: Converting to Stardict format..."
          pyglossary "${base_filename}-formatted.txt" \
            "freedict-${lang_pair}-${file_version}-stardict" \
            --read-format=Tabfile --write-format=Stardict \
            --name="FreeDict-$lang_pair"
          
          # Step 4: Convert HTML to ANSI (if conversion script exists)
          if [[ -f "html2ansi.py" ]]; then
            echo "Step 4: Converting HTML to ANSI..."
            python html2ansi.py "${base_filename}-formatted.txt" "${base_filename}-formatted-html2ansi.txt"
          else
            echo "html2ansi.py not found, using formatted file..."
            cp "${base_filename}-formatted.txt" "${base_filename}-formatted-html2ansi.txt"
          fi
          
          # Step 5: Convert to SDCV format (Stardict variant)
          echo "Step 5: Converting to SDCV format..."
          pyglossary "${base_filename}-formatted-html2ansi.txt" \
            "freedict-${lang_pair}-${file_version}-sdcv" \
            --read-format=Tabfile --write-format=Stardict \
            --name="FreeDict-$lang_pair"
          
          # Step 6: Convert to dictd format
          echo "Step 6: Converting to dictd format..."
          pyglossary "${base_filename}-formatted-html2ansi.txt" \
            "freedict-${lang_pair}-${file_version}-dictd" \
            --read-format=Tabfile --write-format=DictOrg \
            --write-options="dictzip=true" --name="FreeDict-$lang_pair"
          
          # Step 7: Convert to Yomichan format
          echo "Step 7: Converting to Yomichan format..."
          pyglossary "${base_filename}-formatted.txt" \
            "freedict-${lang_pair}-${file_version}-yomichan.zip" \
            --read-format=Tabfile --write-format=Yomichan \
            --name="FreeDict-$lang_pair"
          
          # Step 8: Convert to Aard2 format
          echo "Step 8: Converting to Aard2 format..."
          pyglossary "${base_filename}-formatted.txt" \
            "freedict-${lang_pair}-${file_version}-aard2.slob" \
            --read-format=Tabfile --write-format=Aard2Slob \
            --name="FreeDict-$lang_pair"

      - name: Create ZIP archives for individual dictionaries
        if: steps.check_version.outputs.should_continue == 'true'
        run: |
          lang_pair="${{ steps.check_version.outputs.lang_pair }}"
          file_version="${{ steps.check_version.outputs.FILE_VERSION }}"
          
          # Create ZIP files for Stardict formats
          for prefix in "freedict-${lang_pair}-${file_version}-stardict" \
                       "freedict-${lang_pair}-${file_version}-sdcv"; do
            if [[ -f "${prefix}.ifo" && -f "${prefix}.idx" ]]; then
              # Check which dict file exists
              if [[ -f "${prefix}.dict.dz" ]]; then
                dict_file="${prefix}.dict.dz"
              elif [[ -f "${prefix}.dict" ]]; then
                dict_file="${prefix}.dict"
              else
                echo "No dict file found for $prefix, skipping"
                continue
              fi
              echo "Creating ${prefix}.zip"
              zip -j "${prefix}.zip" "${prefix}.ifo" "$dict_file" "${prefix}.idx"
            else
              echo "Missing required files for $prefix, skipping"
            fi
          done
          
          # Create ZIP file for dictd format
          if [[ -f "freedict-${lang_pair}-${file_version}-dictd.dict.dz" && \
                -f "freedict-${lang_pair}-${file_version}-dictd.index" ]]; then
            echo "Creating freedict-${lang_pair}-${file_version}-dictd.zip"
            zip -j "freedict-${lang_pair}-${file_version}-dictd.zip" \
              "freedict-${lang_pair}-${file_version}-dictd.dict.dz" \
              "freedict-${lang_pair}-${file_version}-dictd.index"
          fi
          
          # List created files
          echo "Created individual files:"
          ls -la *.zip *.slob 2>/dev/null || echo "No zip or slob files found"

      - name: Generate SHA256 checksums for individual files
        if: steps.check_version.outputs.should_continue == 'true'
        run: |
          lang_pair="${{ steps.check_version.outputs.lang_pair }}"
          file_version="${{ steps.check_version.outputs.FILE_VERSION }}"
          
          echo "Generating SHA256 checksums for $lang_pair $file_version"
          
          # Generate checksums for all relevant files
          for pattern in "_freedict-${lang_pair}-${file_version}*.txt" \
                        "freedict-${lang_pair}-${file_version}*.zip" \
                        "freedict-${lang_pair}-${file_version}*.slob"; do
            for file in $pattern; do
              if [[ -f "$file" ]]; then
                sha256sum "$file" > "${file}.sha256"
                echo "Generated SHA256 for $file"
              fi
            done
          done
          
          # List generated checksum files
          ls -la *.sha256 2>/dev/null || echo "No checksum files generated"

      - name: Upload artifacts for collection
        if: steps.check_version.outputs.should_continue == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: dict-${{ steps.check_version.outputs.lang_pair }}-${{ steps.check_version.outputs.FILE_VERSION }}
          path: |
            _freedict-${{ steps.check_version.outputs.lang_pair }}-${{ steps.check_version.outputs.FILE_VERSION }}*.txt
            freedict-${{ steps.check_version.outputs.lang_pair }}-${{ steps.check_version.outputs.FILE_VERSION }}*.zip
            freedict-${{ steps.check_version.outputs.lang_pair }}-${{ steps.check_version.outputs.FILE_VERSION }}*.slob
            *.sha256
          retention-days: 1
          if-no-files-found: warn

  # Third job: collect all processed files and create a single release
  create-combined-release:
    needs: [discover-dictionaries, process-dictionaries]
    if: ${{ fromJson(needs.discover-dictionaries.outputs.matrix).lang_pair[0] != null }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y zip

      - name: Download all dictionary artifacts
        run: |
          echo "Downloading all dictionary artifacts..."
          mkdir -p all-dictionaries
          
      - name: Get current date for release tag
        id: date
        run: |
          # Get current date in YYYYMMDD format
          current_date=$(date -u +"%Y%m%d")
          echo "RELEASE_DATE=$current_date" >> $GITHUB_OUTPUT
          echo "Release will be tagged as: $current_date"

      - name: Collect all artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-dictionaries
          pattern: dict-*
          merge-multiple: true

      - name: List collected files
        run: |
          echo "Collected files structure:"
          find all-dictionaries -type f | sort
          echo ""
          echo "Total files found: $(find all-dictionaries -type f | wc -l)"

      - name: Create collection zip files
        run: |
          echo "Creating collection zip files..."
          
          # Create collections directory
          mkdir -p collections
          
          # 1. All aard2.slob files
          echo "Creating all-aard2.zip..."
          find all-dictionaries -name "*.slob" -type f | xargs -I {} cp {} collections/ 2>/dev/null || true
          if ls collections/*.slob 1> /dev/null 2>&1; then
            cd collections && zip -j all-aard2.zip *.slob && cd ..
            echo "Created all-aard2.zip with $(ls collections/*.slob 2>/dev/null | wc -l) files"
          else
            echo "No aard2 files found"
          fi
          
          # 2. All dictd.zip files
          echo "Creating all-dictd.zip..."
          rm -f collections/*.zip
          find all-dictionaries -name "*dictd.zip" -type f | xargs -I {} cp {} collections/ 2>/dev/null || true
          if ls collections/*dictd.zip 1> /dev/null 2>&1; then
            cd collections && zip -j all-dictd.zip *dictd.zip && cd ..
            echo "Created all-dictd.zip with $(ls collections/*dictd.zip 2>/dev/null | wc -l) files"
          else
            echo "No dictd files found"
          fi
          
          # 3. All formatted.txt files
          echo "Creating all-formatted-txt.zip..."
          rm -f collections/*.txt
          find all-dictionaries -name "*formatted.txt" -type f | xargs -I {} cp {} collections/ 2>/dev/null || true
          if ls collections/*formatted.txt 1> /dev/null 2>&1; then
            cd collections && zip -j all-formatted-txt.zip *formatted.txt && cd ..
            echo "Created all-formatted-txt.zip with $(ls collections/*formatted.txt 2>/dev/null | wc -l) files"
          else
            echo "No formatted.txt files found"
          fi
          
          # 4. All stardict.zip files
          echo "Creating all-stardict.zip..."
          rm -f collections/*stardict.zip
          find all-dictionaries -name "*stardict.zip" -type f | xargs -I {} cp {} collections/ 2>/dev/null || true
          if ls collections/*stardict.zip 1> /dev/null 2>&1; then
            cd collections && zip -j all-stardict.zip *stardict.zip && cd ..
            echo "Created all-stardict.zip with $(ls collections/*stardict.zip 2>/dev/null | wc -l) files"
          else
            echo "No stardict files found"
          fi
          
          # 5. All sdcv.zip files
          echo "Creating all-sdcv.zip..."
          rm -f collections/*sdcv.zip
          find all-dictionaries -name "*sdcv.zip" -type f | xargs -I {} cp {} collections/ 2>/dev/null || true
          if ls collections/*sdcv.zip 1> /dev/null 2>&1; then
            cd collections && zip -j all-sdcv.zip *sdcv.zip && cd ..
            echo "Created all-sdcv.zip with $(ls collections/*sdcv.zip 2>/dev/null | wc -l) files"
          else
            echo "No sdcv files found"
          fi
          
          # 6. All yomichan.zip files
          echo "Creating all-yomichan.zip..."
          rm -f collections/*yomichan.zip
          find all-dictionaries -name "*yomichan.zip" -type f | xargs -I {} cp {} collections/ 2>/dev/null || true
          if ls collections/*yomichan.zip 1> /dev/null 2>&1; then
            cd collections && zip -j all-yomichan.zip *yomichan.zip && cd ..
            echo "Created all-yomichan.zip with $(ls collections/*yomichan.zip 2>/dev/null | wc -l) files"
          else
            echo "No yomichan files found"
          fi
          
          # 7. All original tab files
          echo "Creating all-original-txt.zip..."
          rm -f collections/*.txt
          find all-dictionaries -name "*.txt" ! -name "*formatted*" ! -name "*html2ansi*" -type f | xargs -I {} cp {} collections/ 2>/dev/null || true
          if ls collections/*.txt 1> /dev/null 2>&1; then
            cd collections && zip -j all-original-txt.zip *.txt && cd ..
            echo "Created all-original-txt.zip with $(ls collections/*.txt 2>/dev/null | wc -l) files"
          else
            echo "No original txt files found"
          fi
          
          # List all collection files
          echo ""
          echo "Collection files created:"
          ls -la collections/*.zip 2>/dev/null || echo "No collection files created"

      - name: Create README file
        run: |
          current_date="${{ steps.date.outputs.RELEASE_DATE }}"
          echo "Creating README.md for release $current_date"
          
          cat > README.md << EOF
          # FreeDict *-eng Dictionaries Collection
          
          ## Release Date: $current_date
          
          This release contains automatically converted dictionaries from FreeDict project.
          All dictionaries are from various languages to English (*-eng).
          
          ## Collection Files
          
          The following collection files are available:
          
          1. **all-aard2.zip** - All dictionaries in Aard2 (.slob) format
          2. **all-dictd.zip** - All dictionaries in dictd format
          3. **all-formatted-txt.zip** - All dictionaries in formatted tabfile format
          4. **all-stardict.zip** - All dictionaries in Stardict format
          5. **all-sdcv.zip** - All dictionaries in SDCV (Stardict variant) format
          6. **all-yomichan.zip** - All dictionaries in Yomichan format
          7. **all-original-txt.zip** - All dictionaries in original tabfile format
          
          ## Individual Files
          
          Individual dictionary files are organized in the following structure:
          \`\`\`
          freedict-[LANG]-[VERSION]-[FORMAT].[ext]
          \`\`\`
          
          Where:
          - \`[LANG]\` is the language pair (e.g., afr-eng, deu-eng)
          - \`[VERSION]\` is the version (YYYYMMDD for new format, x.y.z for old format)
          - \`[FORMAT]\` is the format (stardict, sdcv, dictd, yomichan, aard2)
          
          ## Source
          
          All dictionaries are sourced from [FreeDict](https://freedict.org/).
          
          ## Automatic Updates
          
          This repository is automatically updated monthly via GitHub Actions.
          New releases are created when dictionary updates are detected.
          
          ## Usage
          
          Choose the format appropriate for your dictionary application:
          - **Stardict/SDCV**: For GoldenDict, StarDict, sdcv
          - **dictd**: For dictd server
          - **Yomichan**: For Yomichan browser extension
          - **Aard2**: For Aard2 dictionary app
          
          EOF
          
          echo "README.md created successfully"

      - name: Generate SHA256 checksums for collections
        run: |
          echo "Generating SHA256 checksums for collection files..."
          cd collections
          for file in *.zip; do
            if [[ -f "$file" ]]; then
              sha256sum "$file" > "${file}.sha256"
              echo "Generated SHA256 for $file"
            fi
          done
          ls -la *.sha256 2>/dev/null || echo "No checksum files generated"
          cd ..

      - name: Create single GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.date.outputs.RELEASE_DATE }}
          name: FreeDict *-eng Collection ${{ steps.date.outputs.RELEASE_DATE }}
          body_path: README.md
          files: |
            collections/*.zip
            collections/*.sha256
            all-dictionaries/**/*
          generate_release_notes: true
          fail_on_unmatched_files: false
          draft: false
          prerelease: false
